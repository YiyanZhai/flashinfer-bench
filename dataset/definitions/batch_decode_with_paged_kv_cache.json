{
  "name": "batch_decode_with_paged_kv_cache",
  "type": "decode",
  "description": "Performs batched decoding using a paged KV cache, sgl + FlashInfer backend.",
  "axes": {
    "B": { "type": "var" },
    "H_qo": { "type": "const", "value": 32 },
    "H_kv": { "type": "const", "value": 8 },
    "D": { "type": "const", "value": 128 },
    "T_kv": { "type": "var" },
    "I": { "type": "var" },
    "NNZ": { "type": "var" }
  },
  "constraints": [
    "H_qo == H_kv * 4",
    "I == B + 1",
    "NNZ == kv_indptr[-1]"
  ],
  "inputs": {
    "q": {
      "shape": ["B", "H_qo", "D"],
      "dtype": "bfloat16"
    },
    "k": {
      "shape": ["T_kv", "H_kv", "D"],
      "dtype": "bfloat16"
    },
    "v": {
      "shape": ["T_kv", "H_kv", "D"],
      "dtype": "bfloat16"
    },
    "kv_indptr": {
      "shape": ["I"],
      "dtype": "int32"
    },
    "kv_indices": {
      "shape": ["NNZ"],
      "dtype": "int32"
    },
    "kv_last_page_len": {
      "shape": ["B"],
      "dtype": "int32"
    },
    "sm_scale": {
      "shape": [],
      "dtype": "float32"
    },
    "logits_soft_cap": {
      "shape": [],
      "dtype": "float32"
    }
  },
  "outputs": {
    "o": {
      "shape": ["B", "H_qo", "D"],
      "dtype": "bfloat16"
    }
  },
  "reference": "import torch\\nimport flashinfer.decode as decode\\n\\ndef run(q, k, v, kv_indptr, kv_indices, kv_last_page_len, sm_scale, logits_soft_cap):\\n    B, H_qo, D = q.shape\\n    H_kv = k.shape[1]\\n    page_size = 64  # default used in FlashInfer\\n\\n    workspace = torch.empty(128 * 1024 * 1024, dtype=torch.uint8, device=q.device)\\n\\n    max_pages = int(kv_indices.max().item()) + 1\\n    kv_cache = torch.empty((max_pages, 2, page_size, H_kv, D), dtype=k.dtype, device=k.device)\\n\\n    flat_idx = kv_indices\\n    k_sel = k.index_select(0, flat_idx)\\n    v_sel = v.index_select(0, flat_idx)\\n    page_ids = flat_idx // page_size\\n    offsets = flat_idx % page_size\\n    for i, pid in enumerate(page_ids):\\n        kv_cache[pid, 0, offsets[i]] = k_sel[i]\\n        kv_cache[pid, 1, offsets[i]] = v_sel[i]\\n\\n    wrapper = decode.BatchDecodeWithPagedKVCacheWrapper(workspace, kv_layout=\\\"NHD\\\")\\n    wrapper.plan(\\n        kv_indptr, kv_indices, kv_last_page_len,\\n        num_qo_heads=H_qo, num_kv_heads=H_kv, head_dim=D,\\n        page_size=page_size,\\n        pos_encoding_mode=\\\"NONE\\\",\\n        data_type=q.dtype,\\n        sm_scale=sm_scale,\\n        logits_soft_cap=logits_soft_cap\\n    )\\n\\n    o = wrapper.run(q, kv_cache)\\n    return {\\\"o\\\": o }"
}
